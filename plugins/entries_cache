package entries_cache;
use strict;
use warnings;

use Data::MessagePack;
use File::Find ();
use File::Temp ();
use File::Copy;
use File::stat ();
use Errno ();
use Time::Piece ();

our $cache_file = "${blosxom::plugin_state_dir}/entries_cache";
our $cache;
our $packer;

sub start { 1 }

sub packer {
    $packer ||= Data::MessagePack->new;
}

sub entries {
    sub {
        my (%files, %indexes, %others) = @_;

        my $cache = do {
            my $data;
            if (open my $fh, '<', $cache_file) {
                local $/;
                $data = <$fh>;
                close $fh;

                $data = packer->decode($data);
            }
            elsif ($! == Errno::ENOENT) {
                $data = {};
            }
            else {
                die $!;
            }

            $data;
        };

        my $needs_update = 0;

        File::Find::find(sub {
            if (
                # a match
                $File::Find::name =~
                    m!^$blosxom::datadir/(?:(.*)/)?(.+)\.$blosxom::file_extension$!

                # not an index, .file, and is readable
                and $2 ne 'index' and $2 !~ /^\./ and ( -r $File::Find::name )
                )
            {
                my $mtime = File::stat::stat($File::Find::name)->mtime or return;

                return unless $blosxom::show_future_entries
                    or $mtime < time;

                my $cached_mtime = $cache->{ $File::Find::name }{mtime};
                if (!$cached_mtime or $mtime != $cached_mtime) {
                    # read meta-creation_date when no cache entry
                    my $t;

                    open my $fh, '<', $File::Find::name or die $!;
                    while (my $line = <$fh>) {
                        last if $line =~ /^\r?\n$/;
                        if ($line =~ /meta-creation_date:\s*(\S+)/) {
                            $t = Time::Piece->strptime($1, '%Y-%m-%dT%H:%M:%S');
                        }
                    }
                    close $fh;

                    $cache->{ $File::Find::name }{mtime} = $mtime;
                    $cache->{ $File::Find::name }{date}  =
                        $t ? $t->epoch : $mtime;

                    $needs_update++;
                }

                $files{ $File::Find::name } =
                    $cache->{ $File::Find::name }{date};
            }

        }, $blosxom::datadir);

        if ($needs_update) {
            # update cache
            my $fh = File::Temp->new or die $!;
            print $fh packer->encode($cache);
            close $fh;

            link $fh->filename => $cache_file
                or move $fh->filename => $cache_file
                    or die $!;
        }

        return (\%files, \%indexes, \%others);
    };
}

1;
